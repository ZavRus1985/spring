модуль 1

Часть 1:
1.	Добавить в предыдущий проект Spring Security.
2.	Добавить механизм in-memory аутентификации.
3.	Добавить механизм db-аутентификации.

Часть 2 (по желанию):
1.	Реализовать так, чтобы одновременно были два бина – in-memory и db (необходимо добавить возможность перед запуском программы выбирать, какой вид аутентификации необходим).
2.	Создать пользователя двумя способами – через MySQL Workbench, через REST-API (controller-service-repository).


модуль 2
Часть 1:
1.	Добавить в проект роли – ADMIN и USER.
2.	Сделать разделение функционала администраторов и обычных пользователей: администратор может выполнять любые операции, обычный пользователь может выполнять только читающие (GET) операции.
3.	Реализовать данный механизм двумя способами: с помощью requestMatchers, с помощью @PreAuthorize.
4.	Изменить извлечение ролей пользователя с EAGER на LAZY.
5.	*Изучить дополнительно теорию по CSRF (без реализации).

Часть 2:
1.	Добавить в проект admin-panel – REST операции, доступные только администратору.
2.	Необходимые операции: сохранение нового пользователя, обновление пароля пользователя, сохранение новой роли, добавление новой роли пользователю, удаление роли у пользователя.
3.	*Реализовать операцию по блокировке пользователя. После блокировки пользователь не должен иметь возможности зайти в приложение.

модуль 3
Часть 1:
1.	Реализовать BasicAuth.
2.	Протестировать форму BasicAuth в браузере и Postman.

Часть 2:
1.	Реализовать кастомную аутентификацию с помощью нового фильтра.
2.	Описание: POST-запрос, в теле которого передаются данные для аутентификации (логин и пароль).
3.	В случае успешной аутентификации необходимо вернуть AuthResponse. Поля определить самостоятельно. Настроить статус и формат ответа.
4.	В случае неуспешной аутентификации также вернуть AuthResponse с сообщением об ошибке. Настроить статус и формат ответа.
5.	Протестировать API с новой аутентификацией и авторизацией.
6.	Изучить компоненты AuthenticationManager, AuthenticationProvider, Authentication, SecurityContext, SecurityContextHolder.
7.	*После аутентификации вывести информацию о текущем авторизированном пользователе. Для этого написать endpoint GET.

модуль 4
Часть 1:
1.	Реализовать JWT-авторизацию по примеру из презентации.
2.	При некорректном запросе на /login (login & password) выдавать сообщение о неверных данных для входа.
3.	При некорректном JWT-токене выдавать информацию о невалидном JWT-токене.
4.	*Разделить информацию о невалидном JWT-токене на три основных: поврежденный JWT-токен (malformed), нарушение проверки подписи (signature), истечение валидности токена (expired). Подсказка: при всех трех ситуациях jwt.io кидает разные исключения.
5.	Проверить, что при разных сценариях приложение возвращает корректные статусы – 200, 401 и 403.

Часть 2:
1.	Реализовать механизм RefreshToken. RefreshToken – токен обновления, который используется для обновления истекшего AccessToken.
2.	RefreshToken издается на более длительное время (например, час). Изменить JwtConfig, описав два поля – время жизни AccessToken и RefreshToken.
3.	При запросе на /login должны генерироваться два токена: AccessToken и RefreshToken. RefreshToken нужен только для обновления AcessToken и не передается в запросах на доступ к API.
4.	Добавить еще один фильтр OncePerRequest, который должен срабатывать только по url /api/refresh-token. На вход в данный фильтр в body передается только RefreshToken. В случае валидности RefreshToken генерируется новая пара AccessToken и RefreshToken.
5.	Теперь при истекшем AccessToken должна быть возможность его обновить с помощью RefreshToken. Если истекает и он, то необходимо получать новую пару по /login.
